---
title: "blastn vs insect"
author: "Kimberly Ledger"
date: "2022-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Run blast search on VM 

input = sequences from sequence tables in FASTA format (see final set up filtering for export of the seqtab as a fasta)

[kimberly.ledger@akc0ss-vu-134 NBS_eDNA]$ nohup blastn -db nt -query myasvs.fasta -perc_identity 96 -qcov_hsp_perc 100 -num_threads 10 -out blastnresults_out -outfmt "6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore sscinames staxids"

## Download taxonkit

Instructions here: https://bioinf.shenwei.me/taxonkit/

Essentially: 

Just download compressed executable file of your operating system (https://github.com/shenwei356/taxonkit/releases), and uncompress it with tar -zxvf *.tar.gz command or other tools. 

And then copy to anywhere in the environment variable PATH:

mkdir -p $HOME/bin/; cp taxonkit $HOME/bin/ 

## Use taxonkit to assign full taxonomic information to sequences

To use this, you need to know which column in your BLAST output file contains the staxid (species tax id number). If using the syntax above, column 14 contains this info.

cat blastnresults_out | taxonkit lineage -c -i 14 > 12s_blastn_tax.out

reformat to modify the full lineage into the standard k;p;c;o;f;g;s

taxonkit reformat 12s_blastn_tax.out -i 16 > 12s_blastn_taxlineage.txt

## Now, take a look at the results

this is code just slightly modified from Diana's "04-taxonomy-and-preliminary-analysis.Rmd" 

```{r load-libraries}
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
```

```{r load-output-from-taxonkit}
taxonomy <-read.delim("12s_blastn_taxlineage.txt", header = FALSE, na.strings=c(""," ","NA"))

head(taxonomy)
```


# clean up the header a bit

```{r}
# use the full taxonomy rather than the seq id to collapse identical entries
tax_df <- taxonomy %>%
  filter(V4 > 100) %>% # make sure all retained matches are >100 bp
  select(-V2, -V5, -V6, -V7, -V14, -V8, -V9, -V10, -V11, -V12, -V15, -V16) %>%  #remove unnecessary columns
  group_by(V1, V17) %>% # group by the sequence key and the full taxonomy to reduce duplicate entries
  unique() %>% # doing that reduced the number of entries from 146k to 17k
  rename(qseqid=V1, perc_id=V3, length=V4, sscinames=V13, taxonomy=V17) %>% #rename headers
  filter(!str_detect(sscinames, "environmental")) %>% # filter out any environmental samples
  filter(!str_detect(sscinames, "synthetic")) #%>% # filter out any synthetic "samples"
  #filter(perc_id >= 98) # seems like some of the matches below 98% are dubious (jellyfish and herring <1% different??)
```

```{r how-many-total-ASVs-w-taxonomy}
tax_df %>% 
  ungroup() %>%
  select(qseqid) %>%
  unique()
```


### taxonomy clean-up

```{r}
# find sscinames that include numbers or "sp."
tax_df %>%
  filter(str_detect(sscinames, " x "),
         sscinames != "Oncorhynchus mykiss x Salmo salar",
         sscinames != "Platichthys stellatus;Liopsetta pinnifasciata;Platichthys stellatus x Parophrys vetulus",
         sscinames != "Salvelinus fontinalis x Salvelinus malma")
```

```{r}
# formatting the taxonomy variables
taxon_df <- tax_df %>%
  filter(str_detect(taxonomy, ";")) %>%
  separate(taxonomy, into=c("kingdom", "phylum", "class", "order", "family", "genus", "species"), sep = ";")

```


Manually dealing with messy hybrid data:
```{r}
fixed_tax_df <- taxon_df %>%
  ungroup() %>%
  mutate(species = ifelse(str_detect(species, " x "), NA, species)) %>%
  mutate(species = ifelse(str_detect(sscinames, " sp. "), NA, species)) %>% # if the ssciname includes sp., then it shouldn't be assigned at the species level.
   mutate(species = ifelse(str_detect(species, "[:digit:]"), NA, species)) %>% # remove species names that include digits.
  mutate(order = ifelse(species == "Cymatogaster aggregata", "Perciformes", order)) %>%
  mutate_all(na_if,"") %>% # change any blank cells to NA
   # and fix the species syntax with underscores
   mutate_if(is.character, str_replace_all, ' ', '_') %>%
    filter(species != "natural_gynogenetic_Carassius_auratus_red_var.") %>% # remove this entry.
    mutate(order = ifelse(family == "Salmonidae", "Salmoniformes", order)) %>%
    mutate(order = ifelse(family == "Ictaluridae", "Siluriformes", order)) %>%
    mutate(order = ifelse(family == "Sebastidae", "Scorpaeniformes", order)) %>%
    mutate(order = ifelse(family == "Cottidae", "Scorpaeniformes", order)) %>%
    mutate(order = ifelse(family == "Zoarcidae", "Perciformes", order)) %>%
    mutate(order = ifelse(family == "Moronidae", "Perciformes", order)) %>%
    mutate(order = ifelse(family == "Stichaeidae", "Perciformes", order)) %>%
      mutate(order = ifelse(family == "Cyprinidae", "Cypriniformes", order))

# fixing NAs
fixed_tax_df %>%
  filter_all(any_vars(is.na(.))) 
```

## Sort and clean-up the results based on % identity

```{r total-n-seqs}
# how many total sequences?
fixed_tax_df %>%
  select(qseqid) %>%
  unique()
```

There are four categories:
1. sequences that match a single species unambiguously (the minority)

Sequences that match multiple species are divided in three categories:
2. top matches > 2% identity than second-ranked matches
3. top matches < 2% identity than second-ranked matches
4. Multiple top matches with the same % identity

```{r}
# 1. sequences that are unambiguously a single species
single_spp_seqs <- fixed_tax_df %>% 
  group_by(qseqid) %>%
  add_tally(name = "n_taxa") %>%
  filter(n_taxa == 1)
  
```


```{r}
# remove the single-species seqs from the dataframe and then rank the hits by % identity for the remaining seqs
seq_id_diff <- fixed_tax_df %>%
  anti_join(., single_spp_seqs) %>%
  select(-length) %>%
  group_by(qseqid, species, genus, family, order, class, phylum, kingdom) %>%
    mutate(seq_percID = max(perc_id)) %>%
    group_by(qseqid, species, genus, family, order, class, phylum, kingdom, seq_percID) %>%
  summarise(max(seq_percID)) %>% # take just the top hit for each taxon (for each sequence)
  select(-`max(seq_percID)`) %>%
  ungroup() %>%
  group_by(qseqid) %>%
      mutate(id_rank = rank(desc(seq_percID), ties.method = "min")) %>% # rank the taxonomic hits per sequence by % id
       mutate(top_perc = max(seq_percID)) %>% # designate the highest % id for the best taxonomic hit in each sequence (in some, but not all cases, this is 100%)   
      mutate(diff = top_perc - seq_percID) %>% # calculate the difference between the % identity of the top hit and each subsequent taxonomic hit
        arrange(diff)

seq_id_diff %>%
  filter(diff > 0)
```

Now I have the single best entry for each species for each sequence ranked and with the difference between the first and second ranked entries calculated.

For sequences with multiple top hits, where the difference between ranked taxa = 0, I will end up defaulting to genus- or family-level ID (or carrying the individual species info around in some capacity). I will do the same for any sequences where the difference betweeen the first and second ranked taxa is < 2%.


Figure out which differences are > 2% and eliminate those first?
```{r}
# filter out any taxa that are >2% less matching identity than the top taxonomic hit for a given sequence
to_remove_low_perc_hits <- seq_id_diff %>%
  ungroup() %>%
  group_by(qseqid) %>%
  filter(diff > 2)

keepers <- seq_id_diff %>%
  anti_join(to_remove_low_perc_hits)
```

```{r}
# this data frame includes only those taxonomic hits that should be considered.
# so now I need to determine whether they should be assigned to genus, family, order, etc. 
singletons <- keepers %>%
  select(qseqid) %>%
  tally() %>%
  filter(n == 1)

# these are the seqs that now have only a single match
singleton_df <- singletons %>%
  left_join(keepers) %>%
  select(-n) %>%
  bind_rows(single_spp_seqs) %>% # combine the single spp data
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)

## Genus-level matches
# remove the singletons from the bigger df 
single_genus <- keepers %>%
  anti_join(singleton_df)%>% # at best, these should be genus-level matches
  group_by(qseqid, genus) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single genus
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "genus") %>%
  mutate(taxon = genus)
  

## Family-level matches
single_family <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  group_by(qseqid, family) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single family
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "family") %>%
  mutate(taxon = family)


## Order-level matches
single_order <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  group_by(qseqid, order) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single order
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "order") %>%
  mutate(taxon = order)


## Class-level matches
single_class <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  group_by(qseqid, class) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single class
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "class") %>%
  mutate(taxon = class)


## Phylum-level matches
single_phylum <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  anti_join(single_class) %>%
  group_by(qseqid, phylum) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single phylum
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "phylum") %>%
  mutate(taxon = phylum)

# Kingdom level matches
single_kingdom <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  anti_join(single_class) %>%
  group_by(qseqid, kingdom) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single kingdom
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "kingdom") %>%
  mutate(taxon = kingdom)
```


Modify the singleton_df to include the right variable headers
```{r}
single_spp <- singleton_df %>%
  select(-perc_id, -length, -sscinames, -n_taxa) %>%
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)

single_spp %>%
    filter(str_detect(species, "sapiens"))
```

```{r}
# recombine the full data set now that the appropriate level of taxonomy has been determined
sorted_tax_df <- bind_rows(single_kingdom, single_phylum, single_class, single_order, single_family, single_genus, single_spp)
```


Create output taxonomy data frames
```{r}
uncollapsed_taxonomy <- sorted_tax_df %>%
  select(-top_perc, -id_rank) %>%
  unique()

# and then collapse that down to just a single taxon per ASV
collapsed_taxonomy <- uncollapsed_taxonomy %>%
  select(qseqid, taxon, taxonomic_level) %>%
  unique()

# which taxonomic entries are still causing issues?
# fine <- uncollapsed_taxonomy %>%
#   filter(is.na(taxon)) %>%
#   #filter_if(is.character, any_vars(is.na(.)))     
#   filter(across(c(species, genus, family, order, class), ~!is.na(.)))

# uncollapsed_taxonomy %>%
#   filter(is.na(taxon)) %>%
#   anti_join(., fine)

# no remaining issues with NAs
```


remove "<" from qseqid in collapsed taxonomy
```{r}
collapsed_taxonomy2 <- collapsed_taxonomy %>% 
  separate(qseqid, c("x", "ASV")) %>%
  select(!x)
```


output taxonomic assignment of AVS's
```{r}
write.csv(collapsed_taxonomy2, "asv_taxonomy_blastn.csv")
```



## cool... now let's put this back together with some sample data 


## Read in ASV-sample table for Poolseq data

```{r ASV-sample-table}
asv_tbl <- read.csv("MiFish_ASVtable.csv") %>%
  rename(sample = X)

head(asv_tbl)

asv_tbl <- asv_tbl %>%
  mutate(sample = str_replace(sample, "-", "_"))
```

Combine taxonomy and sample ASV table
```{r merge-taxonomy-and-sample-tbl}
# pivot longer for ease of joining
asv_long_tbl <- asv_tbl %>%
  pivot_longer(cols = 2:length(asv_tbl), names_to = "ASV", values_to = "count") %>%
  filter(count != 0) # remove entries with no reads

# join data frames
collapsed_tax_df <- asv_long_tbl %>%
  left_join(., collapsed_taxonomy, by = c("ASV")) %>%
  select(!x)  #%>%
  #filter(taxon != "Actinopteri") # this might be messing up the positive controls, so keep them in for the time being.


# how many ASVs without taxonomy at this stage?
collapsed_tax_df %>%
  #filter(is.na(taxon)) %>%
  filter(!is.na(taxon)) %>%
  select(ASV) %>%
  unique()

```
14 ASVs without taxonomy at this stage.
215 ASVs with taxonomy.

```{r}
# save that output
collapsed_tax_df %>%
  write_csv("nbs_taxonomy_df.csv")

```



Collapse down the taxonomic information before plotting.
```{r}
tmp.df <- collapsed_tax_df %>%
  group_by(sample, taxon) %>%
  mutate(total_taxon_ct = sum(count)) %>%
  select(sample, taxon, total_taxon_ct) %>%
  unique()

```




